<?xml version="1.0" encoding="UTF-8"?>
<job xmlns="urn:proactive:jobdescriptor:dev" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:proactive:jobdescriptor:dev ../../src/scheduler/src/org/ow2/proactive/scheduler/common/xml/schemas/jobdescriptor/dev/schedulerjob.xsd" name="data-transfer" priority="normal" cancelJobOnError="true">
    <variables>

        <!-- A to B : direction of data flow -->
        <!-- atob can be : true false -->
        <variable name="atob" value="true"/>

        <!-- wildcard : full file path regex to filter files to be copied -->
        <!-- wildcard can be : .* .*\\.log .*\\.txt .*file.* -->
        <variable name="wildcard" value=".*"/>

        <!-- recursive : if the copying mechanism will explore directories too -->
        <!-- recursive can be : true false -->
        <variable name="recursive" value="false"/>

        <!-- detailed : level of verbosity of the report -->
        <!-- detailed can be : true false -->
        <variable name="detailed" value="false"/>

        <!-- A protocol : protocol to be used to access endpoint A (remote) -->
        <!-- a.protocol can be: ftp ftps hdfs http https sftp webdav (supported by Apache VFS 2.0) -->
        <variable name="a.protocol" value=""/>

        <!-- A server : server IP address (or name) to be used to access endpoint A (remote) -->
        <!-- a.server can be : 192.168.0.100 server.org ... -->
        <variable name="a.server" value=""/>

        <!-- A port : port number to be used to access endpoint A (remote) -->
        <!-- a.port can be: 21 22 ... -->
        <variable name="a.port" value=""/>

        <!-- A username : username to be used to access endpoint A (remote) -->
        <!-- a.username can be: user admin root ... -->
        <variable name="a.username" value=""/>

        <!-- A password : password to be used to access endpoint A (remote) -->
        <!-- a.password can be: toto passwd ... -->
        <variable name="a.password" value=""/>

        <!-- A credpath : private key path to be used to access endpoint A (remote) -->
        <!-- a.credpath can be: /home/user/.ssh/id_rsa ... -->
        <variable name="a.credpath" value=""/>

        <!-- A credname : credential file name to be used that contains password to access endpoint A (remote), it must be in $HOME/.credentials -->
        <!-- a.credname can be: ftp-credentials-1.cred ... -->
        <variable name="a.credname" value=""/>

        <!-- A path : path to be used for endpoint A (remote) -->
        <!-- a.path can be: /remote-path/ ... -->
        <variable name="a.path" value=""/>

        <!-- B path : path to be used for endpoint B (local) -->
        <!-- b.path can be: /tmp/ ... -->
        <variable name="b.path" value=""/>

    </variables>

	<taskFlow>
        <task name="copy-files-task">
            <scriptExecutable>
                <script >
                    <code language="groovy">
                        <![CDATA[

import net.minidev.json.*
import org.apache.commons.vfs2.*
import org.apache.commons.vfs2.provider.sftp.*

def atob =  "${atob}".toBoolean()
def wildcard =  "${wildcard}"
def recursive =  "${recursive}".toBoolean()
def detailed =  "${detailed}".toBoolean()

def a_protocol = "${a.protocol}"
def a_server = "${a.server}"
def a_port =  "${a.port}"
def a_username =  "${a.username}"
def a_password =  "${a.password}"
def a_credpath =  "${a.credpath}"
def a_credname =  "${a.credname}"
def a_path =  "${a.path}"

def b_path =  "${b.path}"

println "Initializing A parameters..."

a_password = getCredentials(a_password, a_credname)

def a_options = initializePrivateKeyMechanism(a_credpath)

println "Accessing A server..."

FileObject a_root = VFS.getManager().resolveFile(generateUrl(a_protocol, a_username, a_password, a_server, a_port), a_options)

println "Resolving A path..."

FileObject a_base = a_root.resolveFile(a_path)

println "Resolving B path..."

FileObject b_base = VFS.getManager().resolveFile(b_path)

println "Copying..."

if (atob) {
    b_base.copyFrom(a_base, new CustomFileSelector(wildcard, recursive))
} else {
    a_base.copyFrom(b_base, new CustomFileSelector(wildcard, recursive))
}

println "Generating report..."

def a_files = generateReport(a_base, wildcard, recursive, detailed)
def b_files = generateReport(b_base, wildcard, recursive, detailed)

def json = new JSONObject()

if (atob) {
    json.put("source_files_count", a_files.size())
    json.put("source_files", a_files)
    json.put("destination_matching_files", b_files)
} else {
    json.put("source_files_count", b_files.size())
    json.put("source_files", b_files)
    json.put("destination_matching_files", a_files)
}

result = json.toJSONString()

println "Report: $result"

a_root.close()

////////////////////////////////////////////////////////

def getCredentials(String password, String credname) {

    if (password != null && !password.isEmpty()) {
        println "Using provided password"
        return password
    }

    if (credname == null || credname.isEmpty())
        return null

    def credDir = new File(new File(System.getProperty("user.home")), ".credentials")
    def credFile = new File(credDir, credname)
    if (credFile.exists()) {
        println "Using provided credential file"
        return credFile.text
    } else {
        println "Could not find provided credential file"
        return null
    }

}

def generateUrl(String protocol, String username, String password, String server, String port) {

    if (server == null || server.isEmpty())
        return "file://"

    if (username != null && !username.isEmpty())
        return protocol + "://" + generateUserPart(username, password) + "@" + generateServerPart(server, port)

    if (username == null || username.isEmpty())
        return protocol + "://" + generateServerPart(server, port)

    throw new RuntimeException("Unhandled case")
}

def generateServerPart(String server, String port) {
    if (port == null || port.isEmpty())
        return server
    else
        return server + ":" + port
}

def generateUserPart(String user, String pass) {
    if (pass == null || pass.isEmpty()) {
        return user
    } else {
        return user + ":" + pass
    }
}

def initializePrivateKeyMechanism(def openSshPrivateKeyPath) {
    FileSystemOptions fsOptions = new FileSystemOptions();
    SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking(fsOptions, "no");
    SftpFileSystemConfigBuilder.getInstance().setUserDirIsRoot(fsOptions, false);
    if (openSshPrivateKeyPath != null && !openSshPrivateKeyPath.isEmpty()) {
        println "Using provided private key"
        def files = [new File(openSshPrivateKeyPath)] as File[]
        SftpFileSystemConfigBuilder.getInstance().setIdentities(fsOptions, files);
    }
    return fsOptions
}

class CustomFileSelector implements FileSelector {
    private Boolean recursive
    private String wildcard
    public CustomFileSelector(String wildcard, Boolean recursive) {
        this.wildcard = wildcard
        this.recursive = recursive
    }
    @Override
    boolean includeFile(FileSelectInfo fileInfo) throws Exception {
        return fileInfo.file.getName().path.matches(wildcard)
    }
    @Override
    boolean traverseDescendents(FileSelectInfo fileInfo) throws Exception {
        return (fileInfo.depth==0?true:recursive)
    }
}

def generateReport(FileObject base, String wildcard, Boolean recursive, Boolean detailed) {
    FileObject[] files = base.findFiles(new CustomFileSelector(wildcard, recursive))
    if (detailed) {
        def sourceFiles = new JSONObject()
        for (FileObject f : files)
            sourceFiles.put(f.name.path, getFileProperties(f))
        return sourceFiles
    } else {
        def sourceFiles = new JSONArray()
        for (FileObject f : files)
            sourceFiles.add(f.name.path)
        return sourceFiles
    }
}

def getFileProperties(FileObject f) {
    def fileJson = new JSONObject()
    fileJson.put("path", f.name.path)
    fileJson.put("baseName", f.name.baseName)
    fileJson.put("hidden", f.hidden)
    fileJson.put("readable", f.readable)
    fileJson.put("writeable", f.writeable)
    fileJson.put("contentOpen", f.contentOpen)
    return fileJson
}


]]>
                    </code>
                </script>
            </scriptExecutable>
        </task>
    </taskFlow>
</job>

